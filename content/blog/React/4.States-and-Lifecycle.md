---
title: 4.States and Lifecycle
date: 2019-05-20 11:05:67
category: React
---

**state**는 component의 상태이다.  
props가 component에게 주어지는 data라면  
**state**는 이 props의 값이 변할 때  
변하는 props를 반영해서 UI로 표시할 수 있게 한다.  
  
**lifecycle**은 component가  
만들어지고 렌더되고 사라지는 일련의 과정이다.  
이 과정은 **state**와 관련이 있다.  
  
어떻게 관련 있을까?  
아래 계속 변하는 props를 가진 tick component 예제를 통해  
_component의 lifecycle과 props, state사이 관계_ 에 대해 알아보자  

##변하는 props값을 가진 tick component
우리는 props 값이 변하는 것을  
UI에 업데이트하는 방법을 1가지 배웠다.  

```js{8}
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
```

그 방법은 아래의 과정을 거친다.

1. 바뀐 props값을 argument로 주어 component를 실행한다.
2. component가 return한 새로운 element를 ReactDOM.render()에게 argument로 전달한다.
3. ReactDOM.render()를 다시 실행한다.(하이라이팅된 부분)
  
값이 변할때마다 위 과정을 모두 거치는 것은 비효율적이다.  
우리는 component가 변하는 props값을 스스로 업데이트하길 원한다.  
어떻게 가능할까?  
**props 값이 변하는 것을 UI에 업데이트하는 방법**은 1가지가 _더_ 있다.
아래 tick component를 통해 그 방법을 알아보자.

###encapsulating tick component
tick component는 Clock component를 extract하여  
렌더링 로직과 UI로직을 분리할 수 있다.  

```js{12}
function Clock(props) {
  return (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {props.date.toLocaleTimeString()}.</h2>
    </div>
  );
}

function tick() {
  ReactDOM.render(
    <Clock date={new Date()} />,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
```

Clock component 즉, tag가 포함된 UI로직을 extract했다.
그 결과, UI요소인 tag들이 **encapsulated** 되어  
어떤 tag를 포함하고 있는지 보이지 않게 되었다.  
기존에 tick component에는 **렌더링 로직**만 남아있게 되었다.  
  
하지만 아직 해결하지 못한 문제가 있다.  
Clock component에게 props로 date 값이  
**고정적으로** 주어지고 있으므로(하이라이팅된 부분)  
매초마다 바뀌는 date 값을 표시하기 위해
setInterval로 tick을 계속 다시 실행해야하는 문제가 남아있다.

###Clock component가 스스로 업데이트하길 원해
우리는 Clock component에게 date값을 _props로 주지 않아도_  
Clock component가 **스스로 업데이트** 하길 원한다.
마치 아래 코드에서 하이라이팅된 부분처럼!

```js{2}
ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

위 코드처럼 props를 주지 않아도  
Clock component가 **스스로 업데이트** 하기 위해서는
Clock component에게 **state**를 주어야한다.  

> state는 props와 비슷하지만 private하고
component에 의해 완전하게 controll 된다.

##function component를 class component로 바꾸기
아래와 같은 과정을 통해 function에서 class로 바꿀 수 있다.

1. class keyword를 사용해서 같은 이름의 component를 선언한다
    (이때 해당 component는 React.component에게 inheritance 받는다)
2. render() method를 class 안에서 선언한다
3. render할 element를 return해주는 부분을 render()안으로 옮긴다
4. render()안에서 props를 this.props로 바꾼다
5. 기존의 function component를 지운다

```js
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

위에 render() method는 업데이트 될때마다 실행된다.  
하지만 같은 DOM node에서 Clock을 render한다면  
Clock class는 한개의 instance를 만들고  
그 instance가 계속 사용되어 진다.  
  
그 결과, local state, lifecycle method 등의  
추가기능을 사용할 수 있다.

###class component에 state 추가하기
아래 과정을 통해 date라는 props를 state로 바꿀 수 있다.

1. this.props.date를 this.state.date로 바꾼다

    ```js{6}
    class Clock extends React.Component {
      render() {
        return (
          <div>
            <h1>Hello, world!</h1>
            <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
          </div>
        );
      }
    }
    ```

2. class constructor를 선언하고 state에 초기값을 준다.

    ```js{4}
    class Clock extends React.Component {
      constructor(props) {
        super(props);
        this.state = {date: new Date()};
      }

      render() {
        return (
          <div>
            <h1>Hello, world!</h1>
            <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
          </div>
        );
      }
    }
    ```

    constructor에 props를 상속한다.

    ```js{2}
    constructor(props) {
      super(props);
      this.state = {date: new Date()};
    }
    ```

3. constructor